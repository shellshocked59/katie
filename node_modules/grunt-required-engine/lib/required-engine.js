var fs = require('fs');
var path = require('path');
var dependencyFactory = require('./dependency-factory');
var CONFIG = require('./config');
var dependencies = [];

function _createDependency(dependencyName, data) {
    var engine;
    var dependency;
    
    engine = JSON.parse(data).engines || '';
    dependency = dependencyFactory.createDependency(dependencyName, engine);
    dependencies.push(dependency);
}

function _processDependency(dependency) {
    var file;
        
    file = [CONFIG.BASE_PROJECT_DIR, 
        'node_modules', 
        dependency, 
        'package.json'].join('/');
    
    file = path.normalize(file);
     _createDependency(dependency, fs.readFileSync(file));
}

function init(dependencies) {
    dependencies = dependencies || [];
    dependencies.forEach(_processDependency);
}

function checkEngineGreaterThan(engine, greaterEngine) {
    var arrVal;
    var arrMax;
    var isGreater = false;
    var index = 0;
    
    if(engine.value === greaterEngine.value && engine.sign === greaterEngine.sign) {
        isGreater = false;
        
    } else if(engine.value === greaterEngine.value) {
        isGreater = engine.sign === '>' && greaterEngine.sign === '>=' ? true : false;
        
    } else {
        arrVal = engine.value.split('.');
        arrMax = greaterEngine.value.split('.');
        
        for(index = 0; index<3; index++ ) {
            if( parseInt(arrVal[index]) > parseInt(arrMax[index]) ) {
                isGreater = true;
                break;
            }
        }
    }
    return isGreater;
}

function getLatestEngine() {
    var min = { sign: '>=', value: 'X.X.X' };
    var latestEngine;
    
    dependencies = dependencies || [];
    
    dependencies.forEach( function( dependency ) {
        if ((min.value === 'X.X.X' && dependency.hasMinEngine()) ||
            (dependency.hasMinEngine() && 
            checkEngineGreaterThan(dependency.getMinEngine(), min))) {
            min = dependency.getMinEngine();
            latestEngine = dependency;
        }
    });
    
    return latestEngine;
}

function getGreatestEgine() {
    var max = { sign: '=<', value: 'X.X.X' };
    var greaterEngine;
    
    dependencies = dependencies || [];
    
    dependencies.forEach(function (dependency) {
        if ((max.value === 'X.X.X' && dependency.hasMaxEngine()) ||
            (dependency.hasMaxEngine() && 
            !checkEngineGreaterThan(dependency.getMaxEngine(), max))) {
            max = dependency.getMaxEngine();
            greaterEngine = dependency;
        }
    });
    
    return greaterEngine;
}

function getGreatestVersion() {
    var engine = getGreatestEgine();
    var maxEngine = engine && engine.hasMaxEngine() ? engine.getMaxEngine() : false;
    
    return maxEngine ? maxEngine.sign+''+maxEngine.value : '';
}

function getLatestVersion() {
    var engine = getLatestEngine();
    var minEngine = engine && engine.hasMinEngine() ? engine.getMinEngine() : false;
    
    return minEngine ? minEngine.sign+''+minEngine.value : '';
}

function getDependencies() {
    return dependencies || [];
}

// Public file methods.
module.exports = { 
    init: init,
    getDependencies: getDependencies,
    getLatestVersion: getLatestVersion,
    getGreatestVersion: getGreatestVersion
};